\section{System Disk Encryption}
An encrypted system disk prevents that the data contained in it can be cloned or replicated without the passphrase or authentication server. For this design, the disks will be encrypted through a kickstart passphrase and then removed once the remote Tang server is reached. If a non-authorized user gains physical access to the server:
\begin{itemize}
  \item If halted and attempted to change the root password, the encryption passphrase prompt will be requested - which was deleted.
  \item If booted through a Live USB OS, the encrypted partitions remain unreadable.
  \item If the drive is removed/stolen, the disk's data remains cyphered.
\end{itemize}

\newpage
\subsection{LUKS - Linux Unified Key Setup}

According to a paper subscribed by Danut Anton and Emil Simion \footnote[1]{https://ieeexplore-ieee-org.usm.idm.oclc.org/stamp/stamp.jsp?tp=\&arnumber=8678978}, LUKS is one of the most common FDE solutions for Linux-based systems.
FDE works by encrypting every single bit on a storage device, so if the user doesn't have the password, data cannot be recovered. The most common problem for FDE solutions is password management, which at what concerns this implementation, will be handled by a two-level key hierarchy. A strong master key is generated by an OS, which is used to encrypt/decrypt the hard drive. That key has to be split and encrypted with a secret user key and stored on the device, at the beginning of the memory. The advantage of this approach is that you can have multiple systems with multiple keys, allowing you to have multiple decryption Servers.

\vskip 2cm
\begin{figure}
  \includegraphics[width=14cm]{images/image2.png}
  \centering
  \caption{LUKS Operational Diagram}
\end{figure}

\newpage
\subsection{Clevis}

Clevis is a pluggable framework for automated decryption. It can be used to provide automate decryption of data or even automated unlocking of LUKS volumes \footnote[2]{https://github.com/latchset/clevis}.
Once Clevis has subscribed the decryption to a server, the encryption passphrase is removed, which means in a lost communication event, the server won't be able to decrypt, not even with the passphrase. To prevent this Clevis can subscribe up to 8 keys to 8 different servers/users and it can be restricted to how many of them are required as a minimum. If you set a value t=2, means that at least 2 servers have to be available at the moment of decryption.


\subsection{Clevis Puppet Profile}
\begin{lstlisting}[language=Java]
#Clevis Profile
class profile::core::clevis() {
  $packages = [
    'clevis',
    'clevis-luks',
    'clevis-dracut'
  ]

  ##Add require packages
  package { $packages:
    ensure => 'present',
  }
  ->exec { '/sbin/dracut -f --regenerate-all':
    path   => ['/usr/bin', '/sbin'],
    onlyif => 'test ! -f /usr/lib/dracut/modules.d/60clevis/clevis-hook.sh'
  }
}
\end{lstlisting}

This profile installs the clevis packages needed to encrypt and manage the LUKS encryption drives. This is not quite required, because the clevis packages are being installed during provisioning, but, it grants some useful tools like 'cryptosetup' to check the subscribed Tang servers.

\newpage
\section{Tang Server - Decryption Server}

\subsection{Tang Service}

Tang \footnote[3]{https://github.com/latchset/tang} is a server for binding data to network presence. In simple terms: you have some data, but you only want it to be available when the system containing the data is on a certain, usually secure, network, This is where Tang comes in.
First, the client gets a list of the Tang server's advertised asymmetric keys. This can happen online by a simple HTTP GET.
Second, the client uses one of these public keys to generate a unique, cryptographically strong encryption key. The data is then encrypted using this key. Once the data is encrypted, the key is discarded. Some small metadata is produced as part of this operation which the client should store in a convenient location. This process of encrypting data is the provisioning step.
Third, when the client is ready to access its data, it simply loads the metadata produced in the provisioning step and performs an HTTP POST to recover the encryption key. This process of encrypting data is the provisioning step.

\vskip 2cm
\begin{figure}
  \includegraphics[width=14cm]{images/image3.png}
  \centering
  \caption{LUKS device interaction with Tang Server}
\end{figure}

\newpage
\subsection{Tang Puppet Profile and Role}

\begin{lstlisting}[language=Java]
# Tang Server Encryption Module

class profile::core::tang() {
  #Variables
  $packages = [
    'tang'
  ]

  #Add require packages
  package { $packages:
    ensure => 'present',
  }

  systemd::dropin_file {'override.conf':
    unit    => 'tangd.socket',
    content => @(OVERRIDE/L)
      [Socket]
      ListenStream=7500
      | OVERRIDE
  }
  # Ensure tang service is running
  ->service { 'tangd.socket':
    ensure  => 'running',
    require => Package[$packages],
  }
}
\end{lstlisting}

Tang profile handles the installation of the tangd.socket service, and then modifies it so it listens on port 7500 for incoming connections from clevis-dracut.

\newpage
\section{Lab Testing - Proof of Concept}
\subsection{Kickstart Modifications - Use of Encryption in Provisioning Template}
Since the drive must be encrypted with LUKS early during the provisioning, new Kickstart Provisioning Template and Partition Tables had to be created at Foreman.

\vskip 0.5cm
\begin{lstlisting}[language=bash]
#  Encrypted VDA - Partition Table

ignoredisk --only-use=${BOOT_DEV}
zerombr
clearpart --drives=${BOOT_DEV} --all --initlabel
part /boot     --size=1024 --asprimary --ondrive=${BOOT_DEV}
part /boot/efi --size=200  --asprimary --ondrive=${BOOT_DEV} --fstype=efi
#  Use an easy passphrase, it will be removed one step later
part pv.boot   --size=1 --grow  --encrypted --passphrase=******** --ondisk=${BOOT_DEV}
volgroup ${BOOT_VG} pv.boot
logvol /               --vgname=${BOOT_VG} --size=1 --grow --name=root
\end{lstlisting}

"Encrypted VDA" initialize the System disk with two regular partitions - /boot and /boot/efi - and then a PV, a VG and a LV, been the LV encrypted through LUKS with a temporary password
\begin{lstlisting}
##Kickstart - Encrypted Provisioning Template
#Packages Section
%packages
clevis-dracut
#Post Section - At ******** use the same passphrase written at the Partition Table
%post --log=/mnt/sysimage/root/install.post.log
curl -sfg http://tang01.cp.lsst.org/adv -o adv1.jws
clevis luks bind -f -k- -d /dev/vda3 \
tang '{"url":"http://tang01.cp.lsst.org","adv":"adv1.jws"}' <<< "********"
curl -sf http://tang02.cp.lsst.org/adv -o adv2.jws
clevis luks bind -f -k- -d /dev/vda3 \
tang '{"url":"http://tang02.cp.lsst.org","adv":"adv2.jws"}' \ <<< "********"
cryptsetup luksRemoveKey /dev/vda3 <<< "********"
\end{lstlisting}

In the packages section, clevis-dracut is installed, to then be used at post to communicate with a Tang server(s), subscribe to them and remove the temporary password.

\newpage
\subsection{Test Environment}
\begin{itemize}
  \item Two Tang servers using the tang puppet profile.
  \item A client with the clevis puppet profile.
  \item The client VM (clevis01.cp.lsst.org) is provisioned through PXE with 'Encrypted VDA' Partitioning Table and 'Kickstart Encrypted Provisioning Template'.
  \item During partition creation, clevis01 root partition is encrypted through LUKS with a passphrase.
  \item Then at packages, clevis-dracut is installed to then communicate with the Tang servers at post section.
  \item At post, clevis01 subscribes to the Tang servers (tang01.cp.lsst.org and tang02.cp.lsst.org) and the temporary passphrase encryption key is removed as a decryption mechanism.
\end{itemize}

\begin{figure}
  \includegraphics[width=10cm]{images/image4.png}
  \centering
  \caption{Booting procedure for an enrolled or newly enrolled client.}
\end{figure}

\begin{enumerate}
  \item During boot, the client machine attempts to reach the first Tang server.
  \item If reached, the decryption server hands over the decryption key.
  \item If the first Tang server wasn't reachable, it attempts with the next one in the key slot.
  \item The second Tang server sends the decryption key.
\end{enumerate}

\newpage
\subsection{Lab Results}
\begin{itemize}
  \item The encrypted client clevis01 successfully decrypt during dracut by reaching tang01.
  \item The primary Tang server (tang01) was powered off and the client was able to decrypt through tang02.
  \item Both Tang servers were powered off and the server remains on hold requesting a passphrase (which doesn't exist) until at least one of the Tang servers is back online (Figure 3).
  \item For the scope of this PoC, the deletion and recreation of one or both Tang servers was not done, but presumably the client decryption would not happened and the content would be irrecoverable.
  \item One way of handling the loss of all Tang servers, is to add the keys to lsst-private repo, but key rotation is suggested by the documentation to increase safety.
\end{itemize}

\begin{figure}
  \includegraphics[width=16cm]{images/image1.png}
  \centering
  \caption{Access to LUKS encrypted drive while Tang server is rebooting}
\end{figure}

\newpage
\subsection{Conclusions - Pros and Cons}
\begin{itemize}
  \item The encrypted client clevis01 successfully decrypt during dracut by reaching tang01.
  \item The primary Tang server (tang01) was powered off and the client was able to decrypt through tang02.
  \item Both Tang servers were powered off and the server remains on hold requesting a passphrase (which doesn't exist) until at least one of the Tang servers is back online (Figure 3).
  \item For the scope of this PoC, the deletion and recreation of one or both Tang servers was not done, but presumably, the client decryption would not happen and the content would be irrecoverable.
  \item One way of handling the loss of all Tang servers is to add the keys to lsst-private repo, but key rotation is suggested by the documentation to increase safety.
\end{itemize}